# ============================================================================
# IMPROVED SCRIPTS - Korrigierte Versionen mit Fehlerbehandlung
# ============================================================================

# Alle originalen Scripts bleiben erhalten
ambient_feuerlicht_warm_flicker:
  alias: KL430 - Random Fire (Amber + Dynamic Dim)
  mode: restart
  sequence:
  - target:
      entity_id:
      - light.computer_licht
      - light.buffet_lichtstreifen
    data:
      init_states: 30,55,62
      backgrounds:
      - - 28
        - 50
        - 62
      - - 31
        - 45
        - 74
      - - 33
        - 35
        - 88
      - - 26
        - 55
        - 66
      segments: 0
      brightness: 70
      transition: 900
      transition_range: 500,1500
      hue_range: 26,42
      saturation_range: 35,70
      brightness_range: 10,92
      random_seed: 321
    action: tplink.random_effect

ambient_velvet_rainbow:
  alias: Ambient – Velvet Rainbow
  mode: restart
  sequence:
  - variables:
      hue: 12
      sat: 55
      bri: 46
      step_h: 2
      t: 3
  - repeat:
      count: 100000
      sequence:
      - target:
          entity_id: light.computer_lichtt
        data:
          hs_color:
          - '{{ hue }}'
          - '{{ sat }}'
          brightness_pct: '{{ bri }}'
          transition: '{{ t }}'
        action: light.turn_on
      - delay: '{{ t }}'
      - variables:
          hue: '{{ (hue + step_h) % 360 }}'
  description: ''

ai_bild:
  sequence:
  - action: ai_task.generate_image
    metadata: {}
    data:
      task_name: open AI Bild
  alias: AI Bild
  description: ''

openai_antwort:
  alias: Test – OpenAI generate
  description: Testet die OpenAI-Integration und zeigt die Antwort als Notification
  mode: single
  sequence:
  - data:
      agent_id: conversation.extended_openai
      text: Schreibe eine sehr kurze Statusmeldung.
    action: conversation.process
  - variables:
      ai_response: '{{ conversations()[0].response if conversations() else ''Keine Antwort erhalten'' }}'
  - data:
      title: OpenAI Antwort
      message: '{{ ai_response }}'
    action: persistent_notification.create

openai_antwort_2:
  sequence:
  - action: script.openai_antwort
    metadata: {}
    data: {}
  alias: OpenAI Antwort
  description: ''

# ============================================================================
# VERBESSERTES COVER SCRIPT - Mit Fehlerbehandlung & korrekter Latenz
# ============================================================================
cover_fahre_zeitbasiert:
  alias: "Cover – fahre zeitbasiert (Tuya/SmartLife-kompatibel)"
  description: "Zeitbasierte Positionssteuerung mit Switch-Toggle-Stop für Tuya-Covers (SmartLife Travel Time)"
  mode: restart
  fields:
    cover_entity:
      description: "Cover-Entity-ID (z.B. cover.rollladen_computer_vorhang)"
      required: true
      example: "cover.rollladen_computer_vorhang"
    pos_helper:
      description: "Input Number Entity für Pseudoposition 0-100"
      required: true
      example: "input_number.pos_computer"
    travel_time:
      description: "Vollhub-Zeit in Sekunden (gemessen von 0% bis 100%)"
      required: false
      default: 21
      selector:
        number:
          min: 5
          max: 60
          step: 0.5
          unit_of_measurement: "s"
    position:
      description: "Zielposition 0-100 (0=geschlossen, 100=offen)"
      required: true
      default: 100
      selector:
        number:
          min: 0
          max: 100
          step: 1
          unit_of_measurement: "%"
    invert:
      description: "Richtung invertieren (true = open/close vertauschen)"
      required: false
      default: false
      selector:
        boolean:
    latenz_ms:
      description: "Cloud/WLAN Latenz in Millisekunden (typisch 200-500ms)"
      required: false
      default: 300
      selector:
        number:
          min: 0
          max: 2000
          step: 50
          unit_of_measurement: "ms"
    stop_switch:
      description: "Switch-Entity zum Stoppen via Toggle (optional, auto-detect aus cover_entity)"
      required: false
      example: "switch.kuche_blind_vorhang"

  sequence:
    # ===== VALIDIERUNG DER ENTITIES =====
    - condition: template
      value_template: >
        {% set cover_ok = cover_entity is defined
                         and states(cover_entity) not in ['unknown', 'unavailable'] %}
        {% set helper_ok = pos_helper is defined
                          and states(pos_helper) not in ['unknown', 'unavailable'] %}
        {{ cover_ok and helper_ok }}
      alias: "Prüfe ob Cover und Helper existieren"

    # ===== VARIABLEN BERECHNEN =====
    - variables:
        # Zielposition
        to: "{{ position | int(0) }}"

        # Aktuelle Position aus Helper
        from_pos: >
          {% if states(pos_helper) in ['unknown', 'unavailable'] %}
            0
          {% else %}
            {{ states(pos_helper) | int(0) }}
          {% endif %}

        # Fahrtzeit gesamt
        tt: "{{ travel_time | float(21) }}"

        # Differenz (kann negativ sein)
        diff: "{{ (to - from_pos) | float(0) }}"

        # Rohe Fahrtzeit (ohne Latenzkorrektur)
        raw_time: "{{ (diff | abs) / 100.0 * tt }}"

        # Konstante Latenz (nicht prozentual!)
        latenz_s: "{{ (latenz_ms | int(300)) / 1000.0 }}"

        # Korrigierte Fahrtzeit (mindestens 0.5s)
        dur_s: "{{ [raw_time - latenz_s, 0.5] | max }}"

        # Fahrtrichtung
        is_opening: "{{ to > from_pos }}"
        is_closing: "{{ to < from_pos }}"
        is_same: "{{ to == from_pos }}"

        # Stop-Switch auto-detection
        auto_switch: "{{ cover_entity | replace('cover.', 'switch.') }}"
        final_stop_switch: "{{ stop_switch if stop_switch is defined else auto_switch }}"
        switch_exists: "{{ states(final_stop_switch) not in ['unknown', 'unavailable'] }}"

    # ===== LOGGING FÜR DEBUGGING =====
    - service: system_log.write
      data:
        message: >
          Cover {{ cover_entity }}: {{ from_pos }}% → {{ to }}%
          (Δ={{ diff | round(1) }}%, raw={{ raw_time | round(2) }}s,
          latenz={{ latenz_s }}s, final={{ dur_s | round(2) }}s)
        level: info
      continue_on_error: true

    # ===== CHOOSE: NICHTS / ÖFFNEN / SCHLIESSEN =====
    - choose:
        # ========== FALL 1: NICHTS ZU FAHREN ==========
        - conditions:
            - condition: template
              value_template: "{{ is_same }}"
          sequence:
            - service: system_log.write
              data:
                message: "Cover {{ cover_entity }}: Bereits bei {{ to }}%"
                level: debug
              continue_on_error: true

        # ========== FALL 2: NACH OBEN FAHREN (ÖFFNEN) ==========
        - conditions:
            - condition: template
              value_template: "{{ is_opening }}"
          sequence:
            # Cover öffnen (oder schließen wenn invertiert)
            - choose:
                - conditions:
                    - condition: template
                      value_template: "{{ invert }}"
                  sequence:
                    - service: cover.close_cover
                      target:
                        entity_id: "{{ cover_entity }}"
                      continue_on_error: true
              default:
                - service: cover.open_cover
                  target:
                    entity_id: "{{ cover_entity }}"
                  continue_on_error: true

            # Kurz warten und prüfen ob Cover reagiert hat
            - delay:
                milliseconds: 200

            # Prüfen ob Cover tatsächlich fährt
            - condition: template
              value_template: >
                {{ states(cover_entity) in ['opening', 'closing'] }}
              alias: "Cover muss jetzt fahren"

            # Fahrtzeit abwarten
            - delay:
                seconds: "{{ dur_s }}"

            # STOP senden via Switch Toggle (Tuya/SmartLife-kompatibel)
            - choose:
                - conditions:
                    - condition: template
                      value_template: "{{ switch_exists }}"
                  sequence:
                    - service: switch.toggle
                      target:
                        entity_id: "{{ final_stop_switch }}"
                      continue_on_error: true
                    - service: system_log.write
                      data:
                        message: "Cover {{ cover_entity }} gestoppt via {{ final_stop_switch }}"
                        level: info
                      continue_on_error: true
              default:
                - service: system_log.write
                  data:
                    message: "WARNUNG: Stop-Switch {{ final_stop_switch }} nicht gefunden für {{ cover_entity }}!"
                    level: warning
                  continue_on_error: true

            # Kurz warten bis Cover wirklich steht
            - delay:
                milliseconds: 100

            # Position im Helper speichern
            - service: input_number.set_value
              target:
                entity_id: "{{ pos_helper }}"
              data:
                value: "{{ to }}"
              continue_on_error: true

            # Erfolgs-Log
            - service: system_log.write
              data:
                message: "Cover {{ cover_entity }}: Erfolgreich auf {{ to }}% gefahren"
                level: info
              continue_on_error: true

        # ========== FALL 3: NACH UNTEN FAHREN (SCHLIESSEN) ==========
        - conditions:
            - condition: template
              value_template: "{{ is_closing }}"
          sequence:
            # Cover schließen (oder öffnen wenn invertiert)
            - choose:
                - conditions:
                    - condition: template
                      value_template: "{{ invert }}"
                  sequence:
                    - service: cover.open_cover
                      target:
                        entity_id: "{{ cover_entity }}"
                      continue_on_error: true
              default:
                - service: cover.close_cover
                  target:
                    entity_id: "{{ cover_entity }}"
                  continue_on_error: true

            # Kurz warten
            - delay:
                milliseconds: 200

            # Prüfen ob Cover fährt
            - condition: template
              value_template: >
                {{ states(cover_entity) in ['opening', 'closing'] }}
              alias: "Cover muss jetzt fahren"

            # Fahrtzeit
            - delay:
                seconds: "{{ dur_s }}"

            # STOP senden via Switch Toggle (Tuya/SmartLife-kompatibel)
            - choose:
                - conditions:
                    - condition: template
                      value_template: "{{ switch_exists }}"
                  sequence:
                    - service: switch.toggle
                      target:
                        entity_id: "{{ final_stop_switch }}"
                      continue_on_error: true
                    - service: system_log.write
                      data:
                        message: "Cover {{ cover_entity }} gestoppt via {{ final_stop_switch }}"
                        level: info
                      continue_on_error: true
              default:
                - service: system_log.write
                  data:
                    message: "WARNUNG: Stop-Switch {{ final_stop_switch }} nicht gefunden für {{ cover_entity }}!"
                    level: warning
                  continue_on_error: true

            # Warten
            - delay:
                milliseconds: 100

            # Position speichern
            - service: input_number.set_value
              target:
                entity_id: "{{ pos_helper }}"
              data:
                value: "{{ to }}"
              continue_on_error: true

            # Log
            - service: system_log.write
              data:
                message: "Cover {{ cover_entity }}: Erfolgreich auf {{ to }}% gefahren"
                level: info
              continue_on_error: true

# ============================================================================
# NEUES SCRIPT: Ventilator Wintermodus (falls noch nicht vorhanden)
# ============================================================================
ventilator_wintermodus_low:
  alias: "Ventilator – Wintermodus Low"
  description: "Startet Ventilator im Winter-Modus (niedriger Speed)"
  mode: single
  sequence:
    - service: fan.turn_on
      target:
        entity_id:
          - fan.ceiling_fan
          - fan.ceiling_fan_with_light
      data:
        percentage: 33  # Low speed
      continue_on_error: true

# ============================================================================
# TEST SCRIPT: Cover Stop Switch Verification
# ============================================================================
test_cover_stop_switch:
  alias: "Test: Cover Stop via Switch Toggle"
  description: "Testet Auto-Erkennung des Stop-Switches für Tuya-Covers"
  mode: single
  fields:
    cover_entity:
      description: "Cover Entity zum Testen"
      required: true
      example: "cover.kuche_blind_vorhang"
    stop_switch:
      description: "Optional: Spezifischer Stop-Switch (sonst auto-detect)"
      required: false
      example: "switch.kuche_blind_vorhang"
  sequence:
    # Variables: Auto-detect switch
    - variables:
        auto_switch: "{{ cover_entity | replace('cover.', 'switch.') }}"
        test_switch: "{{ stop_switch if stop_switch is defined else auto_switch }}"
        switch_exists: "{{ states(test_switch) not in ['unknown', 'unavailable'] }}"

    # Log test start
    - service: system_log.write
      data:
        message: >
          TEST START: {{ cover_entity }} mit Stop-Switch {{ test_switch }}
          (Auto-detect: {{ auto_switch }}, Exists: {{ switch_exists }})
        level: info

    # Check if switch exists
    - condition: template
      value_template: "{{ switch_exists }}"
      alias: "Stop-Switch muss existieren"

    # Open cover for 3 seconds
    - service: cover.open_cover
      target:
        entity_id: "{{ cover_entity }}"
      continue_on_error: true

    - service: system_log.write
      data:
        message: "Cover {{ cover_entity }} geöffnet, warte 3 Sekunden..."
        level: info

    # Wait 3 seconds
    - delay:
        seconds: 3

    # Stop via switch toggle
    - service: switch.toggle
      target:
        entity_id: "{{ test_switch }}"
      continue_on_error: true

    # Final log
    - service: system_log.write
      data:
        message: >
          TEST COMPLETE: Stop-Befehl an {{ test_switch }} gesendet.
          Prüfe manuell, ob Cover {{ cover_entity }} gestoppt hat.
        level: info

# ============================================================================
# REUSABLE UTILITY SCRIPTS - Added by Code Review
# ============================================================================

# Notify All Devices - Centralized notification system
notify_all:
  alias: "Notify All Devices"
  mode: parallel
  max: 10
  fields:
    message:
      description: "Message to send"
      example: "Hello!"
      required: true
    title:
      description: "Notification title"
      example: "Alert"
      required: false
  sequence:
    - service: notify.alexa_media_wohnzimmer
      data:
        title: "{{ title | default('Home Assistant') }}"
        message: "{{ message }}"
      continue_on_error: true
    # Add more notification services here as needed

# Bedtime Light Scene - Reusable sleep routine
lights_bedtime:
  alias: "Bedtime Light Scene"
  mode: single
  sequence:
    # Turn off all main lights
    - service: light.turn_off
      target:
        area_id: all
      continue_on_error: true
    
    # Turn on bedroom light at low setting
    - service: light.turn_on
      target:
        entity_id: light.schlafzimmer_licht
      data:
        brightness_pct: "{{ states('input_number.night_mode_brightness')|int(15) }}"
        color_temp_kelvin: 2700
      continue_on_error: true

# All Lights Off - Emergency off switch
all_lights_off:
  alias: "Turn Off All Lights"
  mode: single
  sequence:
    - service: light.turn_off
      target:
        entity_id: all
      continue_on_error: true
    - service: system_log.write
      data:
        message: "All lights turned off via script"
        level: info

# All Covers Open - Morning routine
all_covers_open:
  alias: "Open All Covers"
  mode: single
  fields:
    position:
      description: "Target position (0-100)"
      example: 100
      default: 100
  sequence:
    - service: cover.set_cover_position
      target:
        entity_id:
          - cover.rollladen_computer_vorhang
          - cover.kuche_blind_vorhang
          - cover.yoga_blind_vorhang
          - cover.schlafen_blind_vorhang
      data:
        position: "{{ position }}"
      continue_on_error: true
    - service: system_log.write
      data:
        message: "All covers set to {{ position }}%"
        level: info

# All Covers Close - Security/Night routine
all_covers_close:
  alias: "Close All Covers"
  mode: single
  sequence:
    - service: cover.close_cover
      target:
        entity_id:
          - cover.rollladen_computer_vorhang
          - cover.kuche_blind_vorhang
          - cover.yoga_blind_vorhang
          - cover.schlafen_blind_vorhang
      continue_on_error: true
    - service: system_log.write
      data:
        message: "All covers closed"
        level: info

# Ventilation Check - Reusable outdoor condition checker
check_ventilation_conditions:
  alias: "Check Ventilation Conditions"
  mode: single
  sequence:
    - variables:
        wind_ok: "{{ states('sensor.openweathermap_wind_speed')|float(99) < states('input_number.ventilation_wind_max')|float(8) }}"
        temp_ok: "{{ states('sensor.openweathermap_temperature')|float(99) <= states('input_number.ventilation_temp_max')|float(23) }}"
        rh_ok: "{{ states('sensor.openweathermap_humidity')|float(0) <= states('input_number.ventilation_humidity_max')|float(85) }}"
        dp_ok: "{{ states('sensor.outdoor_dewpoint')|float(99) <= states('input_number.ventilation_dewpoint_max')|float(16) }}"
    - condition: template
      value_template: "{{ wind_ok and temp_ok and rh_ok and dp_ok }}"

# Generic Light Toggle with Brightness
light_toggle_with_brightness:
  alias: "Toggle Light with Smart Brightness"
  mode: single
  fields:
    target_light:
      description: "Light entity to toggle"
      example: "light.wohnzimmer"
      required: true
    brightness_day:
      description: "Brightness during day (%)"
      example: 100
      default: 100
    brightness_night:
      description: "Brightness during night (%)"
      example: 15
      default: 15
  sequence:
    - choose:
        # If light is on, turn off
        - conditions:
            - condition: template
              value_template: "{{ is_state(target_light, 'on') }}"
          sequence:
            - service: light.turn_off
              target:
                entity_id: "{{ target_light }}"
      default:
        # Turn on with appropriate brightness
        - service: light.turn_on
          target:
            entity_id: "{{ target_light }}"
          data:
            brightness_pct: >
              {% set hour = now().hour %}
              {% if hour >= 22 or hour < 6 %}
                {{ brightness_night }}
              {% else %}
                {{ brightness_day }}
              {% endif %}

